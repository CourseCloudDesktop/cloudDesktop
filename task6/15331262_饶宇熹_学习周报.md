# 1 OpenStack概况

## 1.1 OpenStack常用的七个组件

<div align=center> <img src="image/7maincomponents.png" width="50%" height="50%" /></div>

* 负责虚拟机创建、管理和销毁，提供计算资源服务的Nova
* 提供对象存储服务的分布式存储Swift
* 提供块存储服务的Cinder
* 提供虚拟机镜像管理和存储服务的Glance
* 软件定义网络项目Neutron
* 提供身份认证和授权的Keystone
* 提供基于web的GUI的Horizon


## 1.2 OpenStack中四种通信方式


<div align=center> <img src="image/4communicationways.png" width="50%" height="50%" /></div>

四种通信方式为：
* 基于HTTP的RESTfull API的通信
* 基于高级消息队列的信息传输
* 基于数据库连接（基于SQL的通信）
* 基于第三方的通信（Native API）

最主要的是前三种，通信的组件关系如以下三图：

（1）通过http建立通信关系

![通过http建立通讯关系](image/通过http建立通讯关系.png)

（2）通过AMQP建立通信关系

![通过AMQP建立通讯关系](image/通过AMQP建立通讯关系.png)

（3）通过数据库建立通信关系

![通过数据库建立通讯关系](image/通过数据库建立通讯关系.png)



在一个虚拟机的创建过程中，需要各个组件通过上述四种通信方式进行交互，
依次完成虚拟机运行环境的准备、网络和存储的配置，
最后调用hypervisor或libvirt的API来创建虚拟机。



**在整个OpenStack体系结构中，我们小组决定着重学习Nova，并选择nova-scheduler来进行详细的介绍**



# 2 什么是Nova

* 学习OpenStack中的nova组件(总体结构)
* 选择nova-scheduler进行深入学习


## 2.1 Nova的简介


Nova是OpenStack项目，它提供了一种提供计算实例的方法。这样使得Nova成为一个负责管理计算资源、网络、认证、所需可扩展性的平台。 

Nova支持创建虚拟机、 baremetal 服务器（通过使用ironic），并且对系统容器的进行有限的支持。

Nova通过在现有的Linux服务器上运行一组守护进程的方式来提供服务，每个进程都执行不同的功能。面向用户的接口是REST API，而内部Nova组件通过RPC消息传递机制进行通信。

API服务器处理REST请求，这些请求通常涉及数据库读/写，可选地向其他Nova服务发送RPC消息，并生成对REST调用的响应。 大多数Nova组件可以在多个服务器上运行，并且有一个监听RPC消息的管理器。（例外是Nova-compute）。

Nova使用一个所有组件共享的中央数据库。

Nova需要以下OpenStack服务才能实现基本功能：              
* Keystone:这为所有OpenStack服务提供身份和身份验证。              
* Glance:这提供了计算图像存储库。所有的计算实例都是从浏览图像中启动的。              
* Neutron:它负责提供计算实例连接到启动时的虚拟或物理网络。              
 

四者的网络通信关系如下图所示：

![](image/novanetworking.png)



此外，Nova还可以与其他服务集成，包括：持久块存储、加密磁盘和baremetal计算实例。

https://docs.openstack.org/nova/pike/user/architecture.html

## 2.2 Nova的架构及主要组件

官方给出的Nova架构图如下：

![](image/novanew.png)

* `Nova DB`：用于存储数据的SQL数据库。              
* `Nova-API`：接收HTTP请求的组件，通过osl.messaging队列或HTTP转换命令并与其他组件通信。              
* `Nova-scheduler`：决定哪个主机获得实例。                         
* `Nova-compute`：管理hypervisor和虚拟机之间的通信。              
* `Nova-conductor`：处理需要协调的请求，充当数据库代理，或处理对象转换。 
* `nova-console`和`nova-consoleauth`：通过VNC或SPICE客户端来访问虚拟机的界面。


## 2.3 Nova是怎样运作的

结合图进行讲解**创建和启动一台虚拟机**的过程中，Nova主要组件间的交互关系。

Nova中的各个组件基本上都是通过AMQP（RabbitMQ）来做的。

![](image/step.png)

上图中，红色代表通过http建立通信关系，绿色代表通过数据库建立通信关系，蓝色代表通过AMQP建立通信关系。


主要步骤：
* Horizon向Keystone发起REST调用，发出用户名和密码
* Keystone对接受的用户名和密码进行验证，并生成token
* Horizon启动虚拟机操作的命令和将上一步生成的token转换成REST API发送给Nova-API
* Nova-API向Keystone验证token的合法性
* Nova-API通过AMQP向Nova-scheduler发送同步远程调用请求`rpc.call request`，等待获得新的虚拟机实例的条目和host ID
* Nova-scheduler从消息队列里取出上述请求
* Nova-scheduler与Nova DB交互，挑选出一台适合的宿主机来启动虚拟机（后面重点介绍这个过程）
* Nova-scheduler通过AMQP返回给Nova-API调用，发送宿主机的host ID
* Nova-scheduler通过消息队列向Nova-compute发出在上述宿主机上启动虚拟机的异步调用请求`rpc-cast`
* Nova-compute从消息队列里取出上述请求
* Nova-compute通过消息队列向Nova-conductor发送同步调用请求`rpc.call`，获取虚拟机信息（host ID、VM的内存、CPU、硬盘大小等配置信息）
* Nova-conductor从消息队列里取出上述请求
* Nova-conductor与Nova DB交互
* Nova-conductor返回Nova-compute请求的信息
* Nova-compute从消息队列里取出Nova-conductor返回的信息（至此同步调用结束）
* Nova-compute向Glance API发出带有token的REST请求，请求镜像数据
* Glance API向Keystone验证token的合法性

接下来的步骤是为虚拟机准备网络，在这里不详细讨论。


# 3 Nova-scheduler介绍

Nova对虚拟机的调度体现在两个方面：

**placement**
* 解决*把虚拟机放在哪个物理机上启动*的问题，选取一个最合适的计算节点来运行虚拟机
* 由**nova-scheduler**完成，从一堆宿主机（能运行nova-compute服务的机器）中选出一台去创建虚拟机

**migration**
* 解决*虚拟机启动后，运行过程中从哪个物理机迁移到哪个物理机*的问题

## 3.

配置文件`nova.conf`：用于记录和修改nova的配置信息。

通过修改nova.conf文件修改调度器的配置

Nova默认的调度器是filter scheduler


**1. 选择[filter](https://docs.openstack.org/nova/latest/user/filter-scheduler.html)：** 
```
# 把所有的filter都用上
scheduler_available_filters=nova.scheduler.filters.all_filters

# 选择其中的一部分
scheduler_default_filters=ComputeFilter,AvailabilityZoneFilter,ComputeCapabilitiesFilter,ImagePropertiesFilter,ServerGroupAntiAffinityFilter,ServerGroupAffinityFilter

```

实际截图：


**2. 分析RamFilter** 
```
class RamFilter(filters.BaseHostFilter):
    """Ram Filter with over subscription flag"""

    # 两个传入参数：`host_state`和`filter_properties`
    def host_passes(self, host_state, filter_properties):
        """Only return hosts with sufficient available RAM."""
        instance_type = filter_properties.get('instance_type')
        requested_ram = instance_type['memory_mb']
        free_ram_mb = host_state.free_ram_mb
        total_usable_ram_mb = host_state.total_usable_ram_mb
        used_ram_mb = total_usable_ram_mb - free_ram_mb
        return total_usable_ram_mb * FLAGS.ram_allocation_ratio  - used_ram_mb >= requested_ram
```
首先，这个filter有两个传入参数：`host_state`和`filter_properties`
从`filter_properties`里面取出`instance_type`，再从`instance_type`里取出对虚拟机内存的需求

从`host_state`里取出目前空闲内存`free_ram_mb`和总共的可用内存`total_usable_ram_mb`，
再计算出实际这个host上可用内存的大小`used_ram_mb`。

可用内存的大小`used_ram_mb`和创建虚拟机时申请的内存大小作比较。
如果满足条件，则filter把该宿主机留下；否则，filter把该宿主机过滤掉。


**3. 自己写一个filter** 

(1)仿照`RamFilter`写一段自定义filter代码。
如果一个compute结点满足条件就返回True，否则返回False。

```
# myFilter.py

class myFilter(filters.BaseHostFilter):
	def host_passes(self, host_state, filter_properties):
		free_ram = host_state.free_ram_mb
		requested_ram = filter_properties.get('instance_type')['memory_mb']		
		if(free_ram > requested_ram ):
    			return True
		else:
    			return False
```

（2）添加自定义的filter

将`myFilter.py` 放到 `/usr/share/pyshared/nova/scheduler/filters/folder`目录下,
并建立软连接软链接

（3）更filter选择

```
scheduler_available_filters=nova.scheduler.filters.all_filters
```

**3. 自己写一个filter** 

（能写就写，不能写就跳过）

**4. 对虚拟机进行排序（weighting）** 

对filter筛选出的宿主机计算各个维度的开销（capacity）

目标：
* 尽可能负载均衡
* 尽可能负载集中

与`ram_weight_multiplier`的值有关

scheduler_host_subset_size决定在哪台宿主机上启动哪台虚拟机





## 怎样去配置、使用Nova

配置文件`nova.conf`：用于记录和修改nova的配置信息

### 配置和二次开发

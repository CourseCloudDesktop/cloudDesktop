# Nova组件

[一、Nova简介](#1)

[二、Nova核心](#2)

[三、Nova工作流程](#3)

[四、Nova-scheduler的基本设计思路](#4)

[五、实训小结](#5)
<h2 id="1"> Nova简介 </h2>

Nova是OpenStack云中的计算组织控制器。支持OpenStack云中实例（instances）生命周期的所有活动都由Nova处理。这样使得Nova成为一个负责管理计算资源、网络、认证、所需可扩展性的平台。

- 功能和特点：

    - 实例生命周期管理
    - 管理计算资源
    - 网络和认证管理
    - REST风格的API
    - 异步的一致性通信
    - Hypervisor透明：支持Xen,XenServer/XCP, KVM, UML, VMware vSphere and Hyper-V
    
- Nova是openstack中最核心的组件。openstack的其他组件归根结底是为Nova组件服务的。

- Nova服务是由多个子服务构成，子服务是通过RPC实现通信。服务之间有很松的耦合性。

- 概念框架与逻辑框架的对应

![](https://github.com/south270/Image/blob/master/18shixun/task6/11.png?raw=true)

<h2 id="2"> Nova核心 </h2>

- 服务架构

![](https://github.com/south270/Image/blob/master/18shixun/task6/12.png?raw=true)

1、Nova API ：HTTP服务，用于接收和处理客户端发送的HTTP请求

2、Nova Compute ：
- Nova组件中最核心的服务，实现虚拟机管理的功能。

- 实现了在计算节点上创建、启动、暂停、关闭和删除虚拟机、虚拟机在不同的计算节点间迁移、虚拟机安全控制、管理虚拟机磁盘镜像以及快照等功能。

3、Nova Cert ：用于管理证书，为了兼容AWS。AWS提供一整套的基础设施和应用程序服务，使得几乎所有的应用程序在云上运行;

4、Nova Conductor ：RPC服务，主要提供数据库查询功能。

5、Nova Scheduler ：Nova调度子服务。当客户端向Nova 服务器发起创建虚拟机请求时，决定将续集你创建在哪个节点上。

6、Rabbit MQ Server ：
- OpenStack 节点之间通过消息队列使用AMQP（Advanced Message Queue Protocol）完成通信。

- Nova 通过异步调用请求响应，使用回调函数在收到响应时触发。因为使用了异步通信，不会有用户长时间卡在等待状态。

7、Nova Console、Nova Consoleauth、Nova VNCProxy ：Nova控制台子服务。功能是实现客户端通过代理服务器远程访问虚拟机实例的控制界面。

8、nova-volume ： 

- 是创建、挂载、卸载持久化的磁盘虚拟机，运行机制类似nova-computer。
- 同样是接受消息队列中的执行指令，并执行相关指令。
- volume相关职责包括：创建硬盘、删除硬盘，弹性计算硬盘，为虚拟机增加块设备存储。

<h2 id="3"> Nova工作流程 </h2>

- 运行架构

![](https://github.com/south270/Image/blob/master/18shixun/task6/13.png?raw=true)

- nova-api对外统一提供标准化接口，各子模块，如计算资源（computer），存储资源（volume）、网络资源（network）模块通过相应的api接口服务对外提供服务。

- API接口操作DB实现资源数据模型的维护。
     - 通过消息中间件，通知相应的守护进程如nova-compute实现服务接口，api与守护进程共享DB数据库，但守护进程侧重维护状态信息，网络资源状态。
     - 守护进程之间不能直接调用，需要通过api调用，如nova-compute为虚拟机分配网络，需要调用network-api，而不能直接调用nova-network，这样易于解耦合。

- 下面以创建虚拟机为例：
     - 调用nova-api创建虚拟机接口，nova-api对参数进行解析以及初步合法性校验
     - 调用compute-api创建虚拟机vm接口，computer-api根据虚拟机参数（cpu、内存、磁盘、网络、安全组等）信息，访问数据库创建数据模型虚拟机实例记录。
     - computer-api通过rpc的方式将创建虚拟机的基础信息封装成消息发送至消息中间件指定消息队列“scheduler”
     - nova-scheduer订阅了消息队列“scheduler”的内容，接受到创建虚拟机的消息后，进行过滤，根据请求的虚拟资源，即flavor的信息,选择一台物理主机部署，如novan1，nova-scheduler将虚拟机的基本信息、所属物理主机信息发送值消息中间件指定消息队列“computer.novan1”
     - novan1上nova-compute守护进程订阅消息队列“computer.novan1”，接受到消息后，根据虚拟机基本信息开始创建虚拟机
     - nova-computer调用network-api分配网络ip
     - nova-network接受到消息后，从fixedIP表中拿出一个可用的IP，nova-network根据私网资源池，结合DHCP，实现ip分配和ip绑定
     - nova-computer通过调用volume-api实现存储划分，最后调用底层虚拟化技术，部署虚拟机。

<h2 id="4"> Nova-scheduler的基本设计思路(如何选取一个最合适的计算节点来运行虚拟机) </h2>

### 1. 简介

- Openstack中会由多个Instance共享同一个Host，需要提供调度服务来协调和管理Instance之间的资源分配。

- nova-scheduler在创建实例的时候，为实例(Instance)选择出合适的主机（host）

- 源码结构：

![](https://github.com/south270/Image/blob/master/18shixun/task6/14.png?raw=true)


### 2. 目前Nova上存在的调度器方式：

- ChanceScheduler(随机调度器)：从所有正常运行nova-compute服务的HostNode中随机选取来创建Instance
 
- FilterScheduler(过滤调度器)：根据指定的过滤条件以及权重来挑选最佳Instance的Host Node。
 
- Caching(缓存调度器)：是过滤调度器的一种，在其基础上将Host资源信息缓存到本地的内存中，然后通过后台的定时任务从数据库中获取最新的Host资源信息。

- 上述三种调度器均继承了 /nova/scheduler/driver.py中的Scheduler类 这就是所有调度器实现都要继承的基类。因此我们可以通过继承该类并实现其中的接口，定义自己的调度器。

![](https://github.com/south270/Image/blob/master/18shixun/task6/15.png?raw=true)

- 我们可以看出 select_destination()方法是必须重载的。

- 不同的调度器并不能共存，需要在/etc/nova/nova.conf中指定，默认为FilterScheduler;

### 3. FilterScheduler的工作流程

![](https://github.com/south270/Image/blob/master/18shixun/task6/16.png?raw=true)

- Filters：
   - 过滤掉不符合我们的要求或镜像要求的主机，留下符合过滤算法的主机集合。
   - 所有的filter的实现都位于nova/scheduler/filters 目录下

- Weighting：
   - 对过滤得到的主机列表计算weighting权重并排序，获得最佳的Host；
   - 所有的weigher的实现都位于nova/scheduler/weights 目录下

### 4. Filters过滤器

- 首先根据各个Host当前可用的资源情况来过滤掉那些不能满足Instance要求的Host，然后在使用配置文件指定的各种Filters去过滤掉不符合过滤条件的Host。

- 经过Filters过滤后，会得到一个Host列表。

- nova-scheduler需要从数据库中取得当前各个Host的最新的资源使用情况，这些资源的收集存储由nova-compute中定义的数据库同步机制完成，这是周期性的。

- nova-scheduler在选择最佳Host时需要最新的资源数据，所以/nova/scheduler/host_manager:HostState 维护了一份数据，仅保存在当前进程的内存中，每创建一个Instance，nova-scheduler都要将其更新，并从Host可用资源去掉虚拟机使用的部分。

- nova-scheduler只会从数据库同步数据到自身（单向），并没有写数据库的功能。

- 简单的几种过滤器的介绍：

   - AllHostsFilter: 返回所有Hosts
   
   - core_filter: 根据CPU内核数过滤，如果剩余的内核数大于建立实例需要的内核数，则返回TRUE；
   
   - Ram_filter: 根据指定的RAM值选择资源足够的主机
   
   - AvaliabilityZoneFilter：通过可用的区域来过滤主机，保证虚拟机所属的availability_zone与host所属的availability_zone一致
   
   - JsonFilter: 根据JSON串指定的规则选择主机
   
   - ComputeFilter：返回所有处于Active的Hosts
 
- 每个filter类都继承于BaseHostFilter类

#### 5.关键文件及意义
- /nova/scheduler/driver.py: 文件中最重要的就是 Scheduler 类，是所有调度器实现都要继承的基类，包含了调度器必须要实现的所有接口。

- /nova/scheduler/manager.py: 主要实现了 SchedulerManager 类，定义了 Host 的管理操作函数，
     - 如：删除 Host 中的 Instance — delete_instance_info
     
- /nova/scheduler/host_manager.py: 有两个类的实现，都是描述了跟调度器相关的 Host 的操作实现，
     - 类 HostState 维护了一份最新的 Host 资源数据。
     - 类 HostManager 描述了调度器相关的操作函数， EG._choose_host_filters/get_filtered_hosts/get_weighed_hosts
     
- /nova/scheduler/chance.py: 只有 ChanceScheduler 类(随机调度器)，继承自 Scheduler 类，实现随机选取 Host Node 的调度器

- /nova/scheduler/client: 客户端调用程序的入口

- /nova/scheduler/filter_scheduler.py: 只有 FilterScheduler 类(过滤调度器)，继承自 Scheduler 类，实现了根据指定的过滤条件来选取 HostNode 的调度器

- /nova/scheduler/filters 和 /nova/scheduler/weights: 这两个目录下的内容分别对应filter和weigher

### 6.如何选取一个最合适的计算节点来运行虚拟机(源码分析)

一) nova-scheduler 接收 来自 nova-conduct的 build_instances RPC 远程调用

![](https://github.com/south270/Image/blob/master/18shixun/task6/17.png?raw=true)

二) 从 scheduler.rpcapi.SchedulerAPI 到 scheduler.manager.SchedulerManager

- rpcapi采用call方法调用了SchedulerManager的select_destinations的方法
- rpcapi.py中的接口函数会在manager.py中实现实际操作函数

- 在SchedulerManager初始化这里的driver是通过配置文件中的选项值指定的类来返回对象。默认的是FilterScheduler。

![](https://github.com/south270/Image/blob/master/18shixun/task6/18.png?raw=true)

三) 从 scheduler.manager.SchedulerManager 到调度器 FilterScheduler

1.SchedulerManager的select_destinations()方法调用了FillterScheduler的select_destinations() 方法。

![](https://github.com/south270/Image/blob/master/18shixun/task6/19.png?raw=true)

2. FillterScheduler类

![](https://github.com/south270/Image/blob/master/18shixun/task6/20.png?raw=true)

- select_destinations() 

![](https://github.com/south270/Image/blob/master/18shixun/task6/1.png?raw=true)

- _scheduler() 获得满足过滤条件的主机(调度算法)：

![](https://github.com/south270/Image/blob/master/18shixun/task6/2.png?raw=true)

- 上述的函数调用三个非常关键的操作函数：

    - _get_all_host_states: 获取所有的 Host 状态，并且将初步满足条件的 Hosts 过滤出来。
    
    - get_filtered_hosts：使用 Filters 过滤器将第一个函数返回的 hosts 进行再一次过滤。
    
    - get_weighed_hosts：通过 Weighed 选取最优 Host。

四) _get_all_host_states()主要用来去除不活跃的点：

![](https://github.com/south270/Image/blob/master/18shixun/task6/21.png?raw=true)

- 这里的self.host_manager又是什么的？我们可以通过init()函数得知

![](https://github.com/south270/Image/blob/master/18shixun/task6/22.png?raw=true)
![](https://github.com/south270/Image/blob/master/18shixun/task6/23.png?raw=true)

- host_manager根据配置文件导入，默认为nova.scheduler.host_manager.HostManager

![](https://github.com/south270/Image/blob/master/18shixun/task6/4.png?raw=true)

五) get_filtered_hosts() 

- 定义了四个局部函数

![](https://github.com/south270/Image/blob/master/18shixun/task6/24.png?raw=true)

- 这里的filter_handler经过查看得知是nova.scheduler.filters.BaseFilterHandler()

![](https://github.com/south270/Image/blob/master/18shixun/task6/9.png?raw=true)

六) get_weighed_hosts()

![](https://github.com/south270/Image/blob/master/18shixun/task6/25.png?raw=true)

- nova/scheduler/weights.py

![](https://github.com/south270/Image/blob/master/18shixun/task6/26.png?raw=true)

- 主机的权值 = 原来的权值 + 权重 * 当前权值对象赋予主机的权值

<h2 id="5"> 实训小结 </h2>


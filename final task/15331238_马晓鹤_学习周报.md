### 学习周报

[OpenStack回顾](#1)

* [OpenStack的七大组件](#1.1)

[Nova简介](#2)

* [Nova简介](#2.1)
* [Nova的架构与主要组件](#2.2)
* [Nova在虚拟机创建中的作用](#2.3)

[Nova-api介绍与源码分析](#3)

* [Paste Deploy介绍](#3.1)
* [Nova-api分析（一）基本概念](#3.2)
* [Nova-api分析（二）流程分析](#3.3)
* [Nova-api分析（三）简单模拟](#3.4)

[任务中的工作量、学习的路线规划以及心得](#4)



<h2 id="1">OpenStack简介</h2>

<h3 id="1.1">OpenStack的几大组件</h3>


<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m1.png?raw=true" width="60%">

* keyStone -- 身份服务模块
* Nova -- 负责虚拟机创建、管理和销毁，提供计算资源服务
* Glance -- 提供虚拟机镜像管理和存储服务
* Cinder -- 提供块存储服务
* Swift -- 提供对象存储服务
* Neutron -- 提供网络服务
* Horizon -- UI模块


<h2 id="2">Nova简介</h2>

<h3 id="2.1">Nova简介</h3>

Nova是OpenStack Compute的代号，是OpenStack的重要组成部分，也是IaaS的重要组成部分，它负责维护和管理OpenStack的计算资源，虚拟机生命周期管理也就是通过Nova来实现的。

<h3 id="2.2">Nova的架构与主要组件</h3>

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m2.png?raw=true" width="80%">

- **API Server  (Nova-Api)** : 对外提供一个与云基础设施交互的接口，也是外部可用于管理基础设施的唯一组件。
- **Message Queue  (Rabbit MQ Server)** : OpenStack节点之间通过消息队列使用AMQP完成通信。
- **Compute (Nova-Compute)** : 管理实例生命周期，通过Message Queue接收实例生命周期管理的请求，并承担操作工作。
- **Scheduler (Nova-Scheduler)** : 确定为虚拟机请求分配哪个计算主机，通过恰当的调度算法从可用资源池获得一个计算服务。
- **Network Manager (Nova-Network)** : 处理主机的网络配置，包括IP地址分 配、为项目配置VLAN、实现安全组、配置计算节点网络。
- **Volume Manager (Nova-Volume)** : 管理基于LVM（Logical Volume Manager）的实例卷。实现和卷相关的功能，例如新建卷、删除卷、为实 例附加卷、为实例分离卷。

Nova是无共享、基于消息的架构，所以的Nova组件都可以在多台服务器上分布式运行，这就意味着大多数组件与组件之间的通信都需要消息队列，在**Grizzly**版之前，Nova所有组件都会与数据库通信，这样的集中数据库访问在小规模环境下是个不错的选择，但对大集群来说则会产生安全问题，每个节点都具有数据库访问权限，一旦一台服务器被攻破，这个云环境将完全暴露在外，在**Grizzly**版之后，nova-compute所有数据操作均通过消息队列交由nova-conductor来写入或读取数据库，这样就避免了直接访问数据库，提高了安全性，也更加灵活。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m3.png" width="80%">

<h3 id="2.3">Nova在虚拟机创建中的作用</h3>

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m15.png" width="80%">

根据官方提供的流程图，我将OpenStack云主机的创建步骤分为四个阶段：

- KeyStone验证阶段
- Nova服务组件交互
- OpenStack其它组件交互
- 执行创建

**第一阶段：KeyStone验证**

（1）用户使用Dashboard Horizon或者命令行CLI，通过REST API给Identity 服务Keystone发送用户凭据（credentials）并验证（authenticates）。Keystone使用用户凭据进行验证，然后返回一个auth-token。然后后续操作就可以使用这个auth-token通过REST调用请求OpenStack其他的组件。

（2）Horizon或者CLI将launch instance 或者nova-boot转换形成为一个REST API的请求发送给nova-api。

（3）nova-api接到这个请求后，首先向keystone发送一个请求来确认auth-token是否有效和是否有访问权限。Keystone确认auth-token后，发送一个包含角色和权限的更新后的认证头。

（4）nova-api和Nova数据库交互，将用户的创建虚拟机的请求在nova 数据库里记录下来。

**第二阶段：Nova服务组件交互**

（5）nova-api以rpc.call的方式发送一个请求给nova-schedule,让nova-scheduler去选择一个计算节点来创建虚拟机。注意是通过消息队列发送给nova-scheduler。

（6）nova-schedule调度服务会侦听Scheduler队列，从队列中获取数据。

（7）nova-scheduler和Nova数据库交互，通过调度算法，也就是filtering 和weighing最终选择一台运行nova-compute的计算节点，然后nova-schedule将虚拟机信息使用rpc.cast的模式发送至nova-compute.计算节点队列。让nova-compute在选择好的计算节点中去创建实例。

（8）Nova-Compute从队列获取请求。

（9）nova-compute发送一个rpc.call 请求给nova-conductor，去获取实例的信息，比如host ID和选择的Flavor（CPU、内存和磁盘）。

（10）nova-conductor从队列中获取请求。

（11）nova-conductor与nova的数据库进行交互。nova-conductor返回实例的信息。nova-compute从队列中获取实例的信息。

**第三阶段：OpenStack其它组件交互**

在第二阶段nova-compute为了获取到创建实例所需要的资源，比如镜像、网络、存储。会使用在第一阶段用户验证后获取到的auth-tokon分别和镜像服务Glance的glance-api，网络服务Neutron的neutron-server已经块存储服务Cinder的cinder-api进行交互。而且每次对方收到请求后都需要到keystone上去验证auth-token是否有效。

（12）nova-compute使用验证后获取的auth-token发起一个REST调用给glance-api获取镜像。然后nova-compute使用使用镜像ID。从镜像服务中得到Image URI。从（image storage）镜像存储中加载镜像。

（13）glance-api去Keystone上验证auth-token是否有效。如果有效，nova-compute就可以获取镜像的元数据metadata。

（14）nova-compute使用验证后获取的auth-token执行一个REST调用给neutron-server，让neutron-server给分配和配置网络，为实例分配IP地址。

（15）neutron-Server去Keystone验证auth-token是否有效。如果有效，nova-compute就可以获取到网络的相关信息。

（16）nova-compute使用验证后获取的auth-token执行一个REST调用给cinder-api，给实例附加卷存储，也就是云硬盘。

（17）cinder-api去Keystone验证auth-token是否有效，如果有效，那么nova-compute就可以获取到块存储的相关信息。

**第四阶段：执行创建**

在第三阶段，nova-compute已经通过Glance、Neutron和Cinder分别获取到了镜像、网络和存储相关的信息。那么在第四阶段nova-compute就开始创建虚拟机了。

（18）nova-compute为hypervisor的驱动生成数据，并且通过libvirt或者其他API让hypervisor执行请求来创建虚拟机。这样虚拟机创建的交互流程基本结束，剩下的步骤就是hypervisor最终创建虚拟机的流程。

然后nova-api去轮训nova database，查看虚拟机的状态是否变成正确创建虚拟机的状态(Active,none,sunning)，若状态正确，则虚拟机创建正常成功。


<h2 id="3">Nova API介绍</h2>

<h3 id="3.1">Paste Deploy介绍</h3>

python中的WSGI（Web Server Gateway Interface）是Python应用程序或框架与Web服务器之间的一种接口，定义了一套借口来实现服务器与应用端的通信规范。按照一套规范，应用端想要通信，很简单，只需要实现一个接受两个参数的，含有`__call__`方法并返回一个可遍历的含有零个或者多个`string`结果的python对象。

服务端，对于每个http请求，调用一次应用端“注册”的那个协议规定应用必须实现的对象，然后返回相应的响应消息。 WSGI Server唯一的任务就是接收来自client的请求，然后将请求传给application，最后将application的response传递给client。中间存在的一些东西，就需要中间件来处理。

Paste Deployment是用于发现和配置WSGI appliaction和server的系统。对于WSGI application，用户提供一个单独的函数（loadapp），用于从配置文件或者python egg中加载WSGI application。因为WSGI application提供了唯一的单独的简单的访问入口，所以application不需要暴露application的内部的实现细节。

Paste.deploy加载WSGI的应用十分简单，主要是使用`paste.deploy.loadapp`函数，基本用法如下：

```
app = deploy.loadapp("config:%s" % os.path.abspath(conf_file), name=app_name)
```

其中URI存在两种模式：`config:` 和 `egg:` 。 
下面详细的介绍下配置文件模式。 首先了解几个基本的概念：


- **application**: 应用，符合WSGI规范的可调用对象，接受参数`（environ,start_response）`, 调用`start_response`返回状态和消息头，返回结果作为消息体。
- **filter**：过滤器，可调用对象，类型python中的装饰器，接受一个application对象作为参数，返回一个封装后的application。
- **app_factory**:可调用对象，接受参数`（global,**local_conf）`，返回application对象。
- **composite_factory**: 可调用对象，接受参数`（loader,global_config,**local_conf）`, loader有几个方法, `get_app`用于获取wsgi_app, `get_filter`用于加载filter, 返回application对象。
- **filter_factory**: 可调用对象，接受参数`(global_config, **local_conf)`，返回filter对象。

具体的分析nova中的api-paste.ini 文件：

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m4.png" width="80%">

上图就是nova.api.openstack.compute daemon涉及到的大部分配置。从服务启动的过程中，就调用deploy.loadpp使用config方式来load section名为osapi_compute的应用，找到具体的配置文件，就对应到代码行19，是一个composite类型的section，直接调用nova.api.openstack.urlmap中的urlmap_factory函数，其他的三行作为local_conf参数传入。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m5.png" width="80%">

上面的代码就是待用的`urlmap_factory`, 其中158行开始，就将上面三行指定的应用加载进行，构成一个dict类型的urlmap，即不同的http请求路径对应不同的app。然后开始分别加载其中三个application，我们关注`openstack_compute_api_v21_legacy_v2_compatible`应用，由上面代码可知，它在配置文件中是一个composite section，会调用一个`pipeline_factory_v21`函数，查看该函数。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m6.png" width="80%">

提取出这个pipeline中的前n-1个filter，提取最后一个app，然后将filter逆序，再分别应用到这个app上，keystone对应的最后一个app为`osapi_compute_app_v21`，找到具体的section，直接执行APIRouter.factory。到这，这个application就启动来了。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m7.png" width="80%">

<h3 id="3.2">Nova-api分析（一）基本概念</h3>

#### 资源

Restful中，一切都是围绕资源进行操作，OpenStack定义了两种类型的资源：

- **core resource**: 核心资源，可以在`./nova/api/openstack/compute/`目录下面看到servers.py, ips.py, images.py等等文件，它们就是核心资源, 这些资源是云平台的最基础的东西。
- **extension resource**: 扩展资源，在`./nova/api/openstack/compute/schemas/`目录下面有很多文件，这些都是扩展资源，非核心的，例如keypairs.py等等，扩展资源又分为两种情况：
	- 1. 扩展资源本身也是一种资源，只是没那么核心
	- 2. 扩展资源是对核心资源的扩展丰富，例如keypairs就扩展了servers核心资源
	- 3. 当然扩展资源也可以同时具备这两种情况

#### controller

了解了资源之后，还需要了解controller，controller实际上就是代表对该资源的操作集合，controller中定义了很多的操作，这些操作大致上也可以分为三类：

- **CRUD**: 最基本的操作，对资源的index，create，delete, show, update。
- **action**: 基本操作不可能满足所有对资源的操作，若要增加，则使用@wsgi.action装饰
- **extends**: 使用@wsgi.extends装饰了的函数，如果扩展资源扩展某个核心资源，扩展资源增加的函数就会添加这个装饰

#### WSGI APP

在OpenStack中，定义了很多的资源，每个资源有一些操作函数，最终，这每一个资源组成了一个单一的WSGI APP，这就说明了，一个WSGI Server可以对应多个WSGI APP，这样保证了资源之间的独立性。

#### ExtensionManager
存在这么多的资源，需要使用一个较好的方式对他们进行管理，能够方便的为后期添加更多的资源，丰富OpenStack的API。这样就出现了ExensionManager，对这些扩展资源进行统一的管理。

在paste deploy介绍中说过，Nova API的启动最终会运行到`APIRouter class`的构造函数中来，由该函数发散出去，就完成了整个Nova API的启动，该构造函数主要做了下面几件事。

1. 创建一个`ExtensionManager`, 用来加载所有的扩展资源(Extension) 。
2. 调用routes的`Mapper.resource`方法完成对核心资源的定义，建立路由规则 
3. 调用routes的`Mapper.resource`方法完成对扩展资源的定义，也建立路由规则 
4. 将扩展资源对核心资源扩展的`action`或`extends`注册，其实action, extends就是该资源的某个方法。

Nova API service 接收到HTTP请求之后，处理过程主要分为四个阶段:

1. 首先通过WSGI Server将HTTP request封装成wsgi request 
2. 使用api-paste.ini文件中定义的Filter对wsgi request进行处理 
3. 处理完毕后，就根据mapper中的记录，将不同的请求路由到不同的WSGI APP 
4. WSGI APP接收到请求之后，并将请求disptach到controller中的方法上

<h3 id="3.3">Nova-api分析（二）流程分析</h3>

#### Extension Load

APIRouter Class的第一件事，并是创建`ExtensionManager`,然后用它来加载各种extension。
<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m8.png" width="80%">

上面描述了`ExtensionManager`的类继承关系和部分功能，其中关键的函数`_load_extensions`会调用`load_standard_extensions`方法，该方法并遍历schemas目录，该目录是存放所有extension的地方。最终`load_standard_extensions`将schemas目录下的所有extension注册到`ExtensionManager`中，并且是使用的extension的alias(http request中使用到，必须保证它的唯一性，则这样就可以根据http请求，知道是查找哪个extension的controller), 具体的代码形式是：`self.extensions[alias] = ext`。

第二步是定义核心资源，然后使用routes的`Mapper.resource`建立路由关联的关系。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m9.png" width="80%">

`servers.create_resource`就是将该类资源封装成WSGI APP,并且`self.resources`是一个字典类型的变量，就建立了一个key为servers，value为WSGI APP的记录。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m10.png" width="80%">

上面这张图，就说明了controller是怎样定义的，上面提到过，controller有几种类型的成员函数，有两种使用了@wsgi.action或者@wsgi.extends装饰器装饰了的。在controller的元类中，就会有`wsgi_actions`和`wsgi_extends`两个字典，将这些方法收集起来，key为action或者extends的名字，value为该方法，这样http请求中如果有这样的名字，就直接映射到对应的方法上了。

第三步就是对扩展资源使用`mapper.resource`。第一步已经将所有的扩展资源加载起来了，第三步则遍历ExtensionManager中的self.extensions字典，获取其中所有的extensions,如果该extensions定义了新的资源，则将其提取出来，并判断该资源是否继承于self.resource中的某类资源，然后将该资源封装成WSGI APP，建立路由规则。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m11.png" width="80%">

#### HTTP Request

完成上面的这些工作之后，APIRouter的最后一个操作便是将包含了所有的WGSI APP的mapper传递到基类Router中去，Router类是所有wsgi request的入口类，接收到wsgi request后，并将该请求分发到具体的某个WSGI APP。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m12.png" width="80%">

每个WSGI APP必需继承自Application类，然后实现`__call__`方法，在该__call__方法中，并根据http请求的URL,映射到controller上的对应的方法。

查看一个具体的例子，例如nova keypair。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m13.png" width="80%">

<h3 id="3.4">Nova-api分析（三）简单模拟</h3>

开发一个OpenStack 风格的WSGI APP原型需要完成的几方面的工作：

1. 从配置文件中找到WSGI APP程序启动的入口，例如nova的api-paste.ini文件。
2. 定义好APP需要操作的资源。
3. 完成好url到资源的映射。

首先，实现一个`server.py`文件，该文件主要实现一个标准的paste.deploy加载应用的过程。

```
import routes.middleware
import webob.dec
import webob.exc

class Router(object):

    def __init__(self, mapper=None):
        self.map = mapper
        self._router = routes.middleware.RoutesMiddleware(self._dispatch, self.map)

    @classmethod
    def factory(cls, global_conf, **local_conf):
        return cls()

    @webob.dec.wsgify
    def __call__(self, req):
        return self._router

    @staticmethod
    @webob.dec.wsgify
    def _dispatch(req):
        match = req.environ['wsgiorg.routing_args'][1]
        if not match:
            return webob.exc.HTTPNotFound()
        app = match['controller']
        return app
```

第二步，定义一个简单的配置文件mlp_develop.ini，内容很简单，只有两行，告诉程序WSGI APP的入口何在。

```
[app:mlp_develop]
paste.app_factory = router:API.factory
```

第三步，开始实现一个WSGI APP了。这就开始按照前面提到的简单WSGI APP的例子了，需要重载__call__函数，这此基础上，这个app又能完成成url到resources的映射。先实现一个wsgi.py文件，其中定义一个router类，作为基类，重载了__call__函数，但是参数只有一个，因为通过了webob.dec.wsgify的装饰。

```
import routes.middleware
import webob.dec
import webob.exc

class Router(object):

    def __init__(self, mapper=None):
        self.map = mapper
        self._router = routes.middleware.RoutesMiddleware(self._dispatch, self.map)

    @classmethod
    def factory(cls, global_conf, **local_conf):
        return cls()

    @webob.dec.wsgify
    def __call__(self, req):
        return self._router

    @staticmethod
    @webob.dec.wsgify
    def _dispatch(req):
        match = req.environ['wsgiorg.routing_args'][1]
        if not match:
            return webob.exc.HTTPNotFound()
        app = match['controller']
        return app
        
```
第四步，构造url到resource的映射。router.py文件如下：

```
import routes
import wsgi
import mlp_develop

class API(wsgi.Router):

    def __init__(self, mapper=None):
        if (mapper == None):
            mapper = routes.Mapper()

        mlp_develop_resource = mlp_develop.create_resource()
        mapper.connect("/", controller = mlp_develop_resource, action="index")
        super(API, self).__init__(mapper) 
```

第五步，创建mlp_develop的资源类，mlp_develop.py文件。

```
import httplib
import json
import webob.dec
from webob import Response

class Controller(object):
    def __init__(self):
        self.team = "mlp-develop"

    def index(self, req):
        response = Response(request=req,
                            status=httplib.MULTIPLE_CHOICES,
                            content_type='application/json')
        response.body = json.dumps(dict(Branch=self.team))
        return response

    @webob.dec.wsgify
    def __call__(self, request):
        return self.index(request)

def create_resource():
    return Controller()
```

至此，整个wsgi app的原型则创建完毕，大部分openstack的api app都是按照这个思路来实现的，只是他们需要包含的功能更多。可以通过简单的执行python server.py来启动server，然后通过浏览器localhost:8080来访问。最终会得到以下信息。

<img src="https://github.com/CourseCloudDesktop/cloudDesktop/blob/mlp-develop/final%20task/img/m14.png" width="80%">

<h2 id="4">任务中的工作量、学习的路线规划以及心得</h2>
